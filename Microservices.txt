üåê What are Microservices?
################################
Microservices is an architecture style where an application is broken down into small, independent services that communicate over a network (usually HTTP). Each service focuses on a single business function, is independently deployable, and can be developed, scaled, and maintained separately.


üöÄ Why we Use Spring Boot for Microservices?
###########################################
Spring Boot provides all the necessary tools and integrations (e.g., REST APIs, Eureka, Config Server, etc.) to build robust, production-ready microservices quickly.

‚úÖ Benefits of Microservices with Spring Boot:
##############################################
1. Loose coupling between services
2. Independent deployment and scaling
3. Technology flexibility (each microservice can use different tech)
4. Easier debugging, testing, and maintenance
5. Faster time-to-market

What is the lifecycle of Microservices? Design Pattern of Microservices?
########################################################################

The microservice lifecycle starts from design and development, moves through deployment and operation, and ends with monitoring and scaling.‚Äù

Microservice design patterns solve common challenges like communication, scalability, and fault tolerance.
Common patterns include API Gateway, Service Discovery, Circuit Breaker, and Saga.
‚ÄúIn my project, we used API Gateway for routing, Feign Client for synchronous communication, Kafka for asynchronous messaging, Saga pattern for transaction consistency, and Circuit Breaker for fault tolerance.‚Äù



üîß What is a Service Registry in Microservices?(Service-Discovery)
#####################################################
A Service Registry is a central directory where all microservices register themselves so they can be discovered and communicate with each other without hardcoding IPs or URLs.

In Spring Boot, the most common Service Registry is Eureka Server (from Netflix OSS).

Note: 
-> Eureka server runs by default on port 8761.
-> If you run eureka server on port 8761. Client (micro services will automatically register with eureka server)


What is Eureka Server?
#######################
Eureka Server is a service registry in Spring Cloud used for service discovery. .It maintains a list of all microservices and their network locations (IP + port). In main application we annotate @EnableEurekaServer .
When a service starts, it registers itself with the Eureka Server. Other services can look up services from Eureka to communicate with them.


What is Eureka Client?
#######################
Eureka Client is a microservice that registers itself with Eureka Server and can also discover other services. Each microservice (like User Service, Order Service) acts as a Eureka Client.   we use  @EnableEurekaClient in main application to register with eureka discovery.


On startup, it sends a heartbeat to the Eureka Server to stay registered.
It can query Eureka to find the address of other services.
Heartbeat : Eureka Clients periodically send heartbeat to server to maintain registration.


What are the Steps to Create Eureka Server / Service Registry
##############################################################
1.Create a Spring Boot Project 
2.Add Eureka Discovery Server dependency 
3.In your main class, add @EnableEurekaServer annotation which makes this app a Service Registry.
4.Configure application.properties  
server.port=8761                                       //Port of Eureka Server (default: 8761)
eureka.client.register-with-eureka=false               // false because server itself is not a client
eureka.client.fetch-registry=false                     //false because server does not need to fetch services
spring.application.name=eureka-server                  //Name of Eureka Server

üõ†Ô∏è What is Spring Boot Admin Server?
#############################################

"Spring Boot Admin Server is a management and monitoring tool for Spring Boot applications.
It provides a dashboard to monitor health, metrics, logs, and status of microservices in real-time, helping developers and DevOps teams manage distributed applications efficiently."


How Admin Server Works
######################
1.Create a SpringBoot Project   2.Add Admin Server dependency and Web Dependency    3. In main class annotate @EnableAdminServer 
4.configure app.properties  =  server.port=8080   ,  app.name=admin-server  , spring.boot.admin.ui.title=Spring Boot Admin Server
5.In your microservices add AdminClient dependency 
6.configure application.properties in client microservice
spring.boot.admin.client.url=http://localhost:8080
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always 


Why do we need Spring Boot Admin Server when we already have Actuator?
##########################################################################

"Actuator exposes health and metrics endpoints for a single application, but it doesn‚Äôt provide a centralized dashboard. 
 In a microservice architecture with many services, checking each service‚Äôs actuator endpoints manually becomes difficult.
Spring Boot Admin Server solves this by providing a UI dashboard that aggregates data from all microservices in one place. It visualizes health, logs, metrics, memory usage, thread dumps, and more. So, Actuator exposes the data; Admin Server displays and manages it centrally.


Difference Between Eureka Server and Spring Boot Admin Server
################################################################
Eureka Server is a Service Registry .It stores all microservices' locations (IP + port).
It enables Service Discovery.
Microservices register themselves to Eureka, and other services can find them.

üëâ Eureka = Phone Directory of Microservices

Admin Server is a Monitoring Dashboard .It monitors microservices using Actuator endpoints which Shows health, logs, metrics, status, etc.
It Provides a web UI to monitor all services.

üëâ Admin Server = CCTV Monitoring System for Microservices


üì° What is Zipkin Server?
###############################
Zipkin Server is a distributed tracing system that helps you trace and visualize the flow of requests across multiple microservices. It shows you how long each service call takes and helps diagnose latency issues or failures in a microservices architecture.

‚úÖ Key Features of Zipkin:
----------------------------
-> Tracks request paths across microservices (traceId)
-> Shows latency and response time of each service
-> Helps identify bottlenecks or failures
-> Integrates with Spring Cloud Sleuth for automatic tracing

Step to Install Zipikin Server:

1. Download Zipkin Servers: https://zipkin.io/pages/quickstart
2. To run jar file : java -jar file-name
3. Access that on port 9411                

Note: the zikin server and spring cloud sleuth dependeny should be added in client  microservices to check or track in zipkin server 9411


What is Spring Cloud Sleuth? 
#############################
Spring Cloud Sleuth is a distributed tracing library for Spring Boot microservices.
It generates and attaches Trace IDs and Span IDs to every request that flows through your services.

This makes it possible to track a request across multiple microservices.

üëâ Sleuth = Generates tracing IDs
üëâ Zipkin = Stores & displays tracing data


What should I add while creating my first microservice?
###########################################################
"When I create my first microservice, I include Spring Web, Lombok, Spring Data JPA, and the required database driver. I also configure application.properties for port, service name, and DB connection. 
Later, if I build a complete microservices ecosystem, I additionally include Eureka Client, Actuator, Feign Client, Zipkin/Sleuth, and Config Client based on architecture requirements."


Why Can't Browser/Postman Access a Service Using Service Name?
##############################################################
Browser/Postman ‚Üí Needs a real IP/Port (ex: http://localhost:8081)
They do not communicate with Eureka Server, so they can't resolve service names.
ex- http://ORDER-SERVICE/orders     this will not work in Postman.


So how to access application with Service name then?
######################################################
To do so, we have to use client like Feign, Webclient, RestTemplate.
Second These Clients provide load balancer concept. Our microservices will continue to run even when url changes as microservice are being accessed using microservice names from eureka server.


Difference Between Rest Template, Webclient & Feign client
##############################################################
Feature                         | RestTemplate (with setup)  | WebClient (with setup)  | Feign Client (automatic)
------------------------------- | -------------------------- | ----------------------- | --------------------------
Can use microservice name       | Yes                        | Yes                     | Yes
Requires manual configuration   | Yes (@LoadBalanced)        | Yes (@LoadBalanced)     | No  
Built-in load balancing         | Yes                        | Yes                     | Yes
URL hardcoded by default        | Yes                        | Yes                     | No
Effort level                    | Medium                     | Medium                  | Low


Which one to use when?
########################
Use Feign Client if:  You are doing microservices ,You have Eureka/Service Registry
You want simplest calls with load balancing
‚û° Best for Microservices

Use WebClient if:  You want high performance   ,Large traffic  ‚û° Best for reactive or scalable systems

Use RestTemplate if: You maintain old code  ‚û° Not recommended for new projects


What is Feign Client?
#####################
Feign is a declarative REST client that allows microservices to call other microservices using simple Java interfaces.


Why we use Feign?
#####################
We don't need to write boilerplate HTTP code   .Automatically integrates with Eureka Discovery

It has Built-in load balancing  . It Supports fallback (Resilience4j / Hystrix)

it provide Cleaner and more readable code

it Works well in microservice architecture


How Feign Client Works (Internally)
####################################

Step 1: You define an interface      

 @FeignClient(name = "USER-SERVICE")
public interface UserClient {
    @GetMapping("/users")
    List<User> getAllUsers();
}

step 2: Feign creates a dynamic proxy class for this interface.

When you call:   userClient.getAllUsers();   Feign asks Eureka:

üëâ ‚ÄúGive me the instance details of USER-SERVICE.‚Äù
Eureka responds with:

http://192.168.x.x:8081
http://192.168.x.x:8082 

step 3: Spring Cloud LoadBalancer picks one instance: using Round Robin pattern
step 4: Feign builds the HTTP request    -GET http://192.168.x.x:8081/users
Step 5: Sends the HTTP request and Converts response back to Java object  (Feign uses Jackson to convert JSON ‚Üí Java object)


Where do we call a Feign Client?
####################################
You call a Feign client inside your Service layer of a microservice ‚Äî usually from:
‚úî Service class (most common & recommended)

what type of communication is used in Feign Client?
###################################################
‚ÄúFeign Client uses synchronous HTTP-based communication, mainly REST, to communicate between microservices.‚Äù

Why Synchronous?
----> ‚ÄúBecause the calling service waits until the called service sends a response.
This is suitable for request-response type communication.‚Äù

üîπ When to Use Feign Client

Service-to-service communication
CRUD operations
Real-time request‚Äìresponse flow



What Is Load Balancing?
###########################
Load balancing means distributing incoming requests across multiple instances of the same microservice so that no single instance gets overloaded.



How Load Balancing Works With Eureka (Client-Side Load Balancing)
#################################################################
‚ÄúIn microservices with Eureka, load balancing is client-side.
Services do not hardcode URLs; they call other services using service names.
Spring Cloud LoadBalancer fetches all healthy instances from Eureka and distributes requests using round-robin or random strategy.
If one instance goes down, the load balancer automatically reroutes traffic, making the system fault-tolerant and scalable.‚Äù

Round-Robin (default) ->    Each request goes to the next instance in order:


Why do we need Load Balancing?
##############################
‚úî Fault Tolerance -If one instance goes down, traffic automatically shifts to other instances.

‚úî Scalability -You can run more instances when traffic increases.

‚úî Zero downtime -Deploy new versions without stopping old ones (blue-green deployments).

‚úî Better Performance -Distributes load so no single server becomes slow.




What is Spring Cloud Config?
##############################

Spring Cloud Config is a centralized configuration management tool for microservices.

It allows you to keep all application configuration (application.properties / YAML) in one central place
‚Üí instead of keeping configuration individually inside each microservice.

This helps all microservices load configuration from a central Config Server which reads properties from a Git repository during startup (or even refresh at runtime).
.

üîß Why is it needed?
#####################-> In a microservices architecture:
-> Each service may have different configuration (ports, DB URLs, API keys).
-> You may want to change config without redeploying the service.
-> Managing configs across dozens of services becomes very difficult


What is API?
############
‚ÄúAPI is an interface that allows different software systems to interact with each other by exposing functionalities through predefined endpoints or methods.‚Äù


what is API GATEWAY?
#####################
‚ÄúAPI Gateway is a single entry point for all microservices. Instead of the client calling each microservice directly, the client sends the request to the API Gateway.
The gateway decides which microservice should handle the request and forwards it.
It also handles common things like security, routing, logging, and load balancing.‚Äù


Why API GATEWAY is REQUIRED?
###########################
1. Clients don‚Äôt need to remember multiple URLs to call the microservice

2. Centralized Security (JWT, Authentication, Filters) -Instead of adding authentication in each microservice:
do it once in API Gateway.üëâ Saves time and makes system secure.

3. Load Balancing -Gateway connects with Eureka and distributes traffic:
Product Service (8081, 8082, 8083) -Gateway picks one instance automatically.  forüëâ Better performance + fault tolerance.

4. Hides Microservice Details  -Client does NOT need to know:  the ports of microservices.


How to implement API Gateway
############################
Step 1 ‚Äî Create a separate Spring Boot project and give a name api-gateway   (This project will NOT contain business logic.)

Step 2 ‚Äî Add Gateway dependencies (These allow the gateway to talk to Eureka & forward requests.)

         spring-cloud-starter-gateway

         spring-cloud-starter-Netflix-eureka-client

Step 3 ‚Äî Register Gateway with Eureka (@EnableDiscoveryClient)

Step 4 ‚Äî Create Routes -You configure routes to map incoming paths to microservice names (in Application.yml file )

now gateway automatically routes request to correct microservice ...


How to Secure microservice project?
###################################

‚ÄúI secure microservices using a combination of API Gateway + JWT + Spring Security.
API Gateway checks authentication and validates the JWT token. Only valid requests are routed to services.

Microservices use Spring Security for authorization and role-based access.
Service-to-service calls also pass JWT for internal protection.

We use HTTPS for secure communication and apply validations to avoid bad input.
This gives complete end-to-end security in a microservice architecture."





what do you mean by Fault Tolerance?
#####################################
Fault tolerance means the system continues operating even when components fail, by using retries, fallbacks, redundancy, and circuit breakers to avoid full system failure.‚Äù 


What is a Fallback Method?
############################
A fallback method is a backup method that is executed when the main method fails.
It prevents the system from crashing and gives a graceful response instead of an error.

‚úÖ How a Fallback Method Works (Step-by-step)
##################################################
Your service calls another microservice (example: Inventory Service).
If the downstream service: is down ,responds with error ,takes too long (timeout) ,or circuit breaker opens ,üëâ The main method fails.
Instead of throwing an exception, the system automatically calls the fallback method.

The fallback method returns: cached data ,default response ,friendly message ,empty object ,static fallback value ,Your service continues working without breaking the entire flow.


‚úÖ Why Fallback is Important
############################## 
1Ô∏è‚É£ Prevents cascading failures -If one microservice fails, the fallback stops the failure from spreading to other services.

2Ô∏è‚É£ Improves user experience -Even if the backend fails, users still receive a meaningful response instead of an error.

3Ô∏è‚É£ Maintains system availability -Fallback helps the system stay up and running rather than becoming unavailable.

4Ô∏è‚É£ Supports resilience & fault tolerance -It helps the system survive failures without downtime.

5Ô∏è‚É£ Handles timeouts & slow responses -If a service is too slow, fallback avoids waiting too long and returns a quick backup response.

6Ô∏è‚É£ Critical for distributed systems -In microservices, many services depend on each other. Fallback ensures that one failure does not break everything


‚úÖ What is Resilience4j?
#########################
Resilliance4j is a lightweight java library which is used for handling faults inside your microservices architecture .

suppose we have service A and service B inside my microservice Architecture .Service A is repeatedly calling Service B . now if Service B is down and the call from service A to service B is failing .but still repeatedly service A is calling service B . 

in order to prevent that we make use of Resilliance4j library . Resillilance4j provides different pattern for ex - Circuit Breaker, Retry ,Rate Limiter 
it acts a switch between the services to prevent from repeated calls .  it works well with SpringBoot .

üîß Main Components -

1Ô∏è‚É£ Circuit Breaker  -Stops calling a failing service.

2Ô∏è‚É£ Retry -Retries failed calls before fallback.

3Ô∏è‚É£ Rate Limiter -Limits how many requests can be sent.

4Ô∏è‚É£ Bulkhead -Isolates resources (like threads) to avoid full crash.

5Ô∏è‚É£ TimeLimiter  -Sets timeout for slow services.

6Ô∏è‚É£ Fallback -Returns default/cached response when failure happens.


‚úÖ Circuit Breaker ‚Äì Simple Definition
########################################
A circuit breaker is a pattern that stops calling a failing service to prevent the system from crashing and allows it to recover.
It protects the system from cascading failures, and uses fallback until the service recovers.‚Äù


How it works -		
Circuit Breaker has three state Closed, Open ,Half-Open    .      suppose  there is Service A and Service B 
######################################################
Closed - when we say circuit are closed that means request are flowing properly across services.

now suppose service B is down and there is some error limit exceeded then it will go to Open State that means request are not flowing anymore .
 now after certain amount of time it will go half open state in order to check the particular service is up or not. it will repeatedly giving health check request to Service B .if the service B is Up then it will go to closed state again.and if it not up then it will go to again Open State.

| State         | Meaning                            |
| ------------- | ---------------------------------- |
| **Closed**    | Everything OK ‚Üí calls allowed      |
| **Open**      | Service is failing ‚Üí calls blocked |
| **Half-Open** | Test few calls to check recovery   |




What is RateLimiter in Resilience4j?
####################################

A RateLimiter in Resilience4j is used to restrict the number of calls allowed within a given time interval. It prevents systems from being overloaded by too many requests and helps maintain stability under heavy traffic.‚Äù

we need to add Resiiliance4j dependency after that give @RateLimiter annotation  ,you can give any specific name and we ll give a fallback method
in application.pro we ll configure like limitForPeriod that means max no of period that you can call . within specific amount of time (limitRefreshPeriod)
application.properties-
resilience4j.ratelimiter.instances.inventoryService.limitRefreshPeriod=1s
resilience4j.ratelimiter.instances.inventoryService.limitForPeriod=10
resilience4j.ratelimiter.instances.inventoryService.timeoutDuration=0

 RETRY
########

If a service call fails (ex: "appointment-service" returns 500), retry again: 
Example: Retry 3 times ,2 seconds interval
Good for temporary network issues.
‚ö†Ô∏è But don‚Äôt retry very long if service is DOWN ‚Üí use Circuit Breaker + Retry together.

How do you apply in your DoctorAppointmentBooking App
#######################################################
‚ÄúIn my doctor appointment system, I use RateLimiter at the API Gateway and booking endpoint to prevent abuse. Circuit Breaker is applied when Booking Service calls Doctor, Patient, or Payment services to avoid cascading failures. Retry is used for temporary issues like notification and payment. Timeout is set on all external calls, and fallback provides user-friendly messages when services are unavailable.‚Äù

‚ÄúIn my Booking-Service, I used Resilience4j to make the system fault-tolerant.
I added CircuitBreaker and TimeLimiter when calling Doctor-Service, Retry and Bulkhead when calling Payment-Service, and a RateLimiter when calling Notification-Service to avoid overloading email/SMS microservices. This ensures Booking-Service stays stable even if dependent services fail.‚Äù



‚≠ê Saga Pattern (Very Easy Line)
##################################
Saga Pattern means doing a big task in small steps, and if any step fails, we undo the previous steps to keep data correct.
üéØ Example (Doctor Appointment) ‚Äî Super Easy

üè• Real-world Saga Example (Doctor Appointment)
Normal Flow: ->
Block Slot
Create Appointment
Make Payment
Send Confirmation

Failure Flow: ->

Payment failed ‚Üí Saga triggers

Unblock slot
Cancel appointment
Send failure message
Your system becomes consistent, clean, and reliable.

How did you implement saga in your project?
############################################
‚ÄúI implemented the Saga Pattern in my project using the Orchestration approach. I created a dedicated Saga Orchestrator Service that controlled the entire booking workflow. Each microservice (Slot-Service, Booking-Service, Payment-Service, Notification-Service) performed its own local transaction, and whenever a step failed, the orchestrator triggered compensating actions like releasing the slot or canceling the booking. This helped us maintain consistency across services without using distributed transactions.‚Äù