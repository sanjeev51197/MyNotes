Collection Framework      
########################

#Array Introduction: 
1. An array is an indexed collection of fixed no of homogeneous data elements. (or) 
2. An array represents a group of elements of same data type. 
3. The main advantage of array is we can represent huge no of elements by using 
single variable. So that readability of the code will be improved.

Limitations of Object[] array: 
===============================
1. Arrays are fixed in size that is once we created an array there is no chance of 
increasing (or) decreasing the size based on our requirement hence to use arrays 
concept compulsory we should know the size in advance which may not possible 
always. 
2. Arrays can hold only homogeneous data elements. 
Example:  
Student[] s=new Student[10000]; 
s[0]=new Student();//valid 
s[1]=new Customer();//invalid(compile time error) 

3) But we can resolve this problem by using object type array(Object[]).  
Example:  
Object[] o=new Object[10000]; 
o[0]=new Student(); 
o[1]=new Customer();

4) Arrays concept is not implemented based on some data structure hence ready-made 
methods support we can't expect. For every requirement we have to write the code 
explicitly. 
 
To overcome the above limitations we should go for collections concept. 
#########################################################################
1. Collections are growable in nature that is based on our requirement we can 
increase (or) decrease the size hence memory point of view collections concept is 
recommended to use. 
2. Collections can hold both homogeneous and heterogeneous objects. 

3. Every collection class is implemented based on some standard data structure 
hence for every requirement ready-made method support is available being a 
programmer we can use these methods directly without writing the functionality 
on our own. 

Difference Between Arrays and Collections
###############################################################
Arrays are fixed in size, which means once we create an array we cannot change its size. But Collections are growable in nature, so we can dynamically add or remove elements.

From the memory point of view, arrays are not recommended to use because they may cause memory wastage due to fixed size allocation, whereas collections are highly recommended because they manage memory dynamically.

From the performance point of view, arrays are recommended to use because they are faster, while collections are not recommended for high performance due to additional processing overhead.

Arrays can hold only homogeneous data type elements, whereas collections can hold both homogeneous and heterogeneous elements.

There is no underlying data structure for arrays, so there is no readymade method support, but every collection class is implemented based on some standard data structure, so readymade method support is available.

Arrays can hold both primitives and object types, but collections can hold only objects and not primitives                                                                       


#What is Collection in Java?
###############################
Collection is an interface present in java.util pacakage. It is used to represent group of individual object as a single unit.
The main subinterfaces of the collection interface are:  List , Set  , Queue .
If we want to represent a group of objects as single entity then we should go for collections.  
In general we can consider collection as root interface of entire collection framework. 
Collection interface defines the most common methods which can be applicable for any collection object. 


#What is Collection Framework?
################################
The Java Collection Framework provides a set of classes and interfaces to store and manipulate group of data efficiently.
It is part of java.util package.
The root interface of this framework is Collection interface.


What is the difference between Collection and Collections ?
#############################################################
Collection is an interface which represents a group of objects and it is the root interface of the Collection Framework. Classes like ArrayList, LinkedList, and HashSet implement this interface.It contains method declarations like add(), remove(), size()

Collections is a utility class . It is used to provide utility methods for Collection objects. It is a helper class for Collection Framework .
                                 It contains static methods like sort(), reverse(), shuffle(), binarySearch() .



Collection interface: 

ï‚· If we want to represent a group of individual objects as a single entity then we should go for Collection interface. 
This interface defines the most common general  methods which can be applicable for any Collection object. 
ï‚· The following is the list of methods present in Collection interface. 
######################################################################### 
1. boolean add(Object o); 
2. boolean addAll(Collection c); 
3. boolean remove(Object o); 
4. boolean removeAll(Object o); 
5. boolean retainAll(Collection c); 
To remove all objects except those present in c. 
6. Void clear(); 
7. boolean contains(Object o); 
8. boolean containsAll(Collection c); 
9. boolean isEmpty(); 
10. Int size(); 
11. Object[] toArray(); 
12. Iterator iterator(); 

Example -

public class CollectionInterfaceMethodEx {
	
	
	public static void main(String[] args) {
		
		
		Collection<String> c1=new ArrayList<String>();
		
	     //add(object o)
		
		c1.add("java");
		c1.add("Python");
		c1.add("Spring");
		c1.add(null);
		System.out.println("After add(): "+ c1);
		
		//creating another collection
		Collection<String> c2=new ArrayList<String>();
		    c2.add("Docker");
		    c2.add("Kubernetes");
		    
		    
		c1.addAll(c2);
		System.out.println("After adding addAll(): "+c1);
		
		
		//remove object o
		
		c1.remove(null);
		System.out.println("after remove(): "+c1);
		
		
		//removeALl
		
		c1.removeAll(c2);
		System.out.println("After removeAll(): "+c1);
		
		
	    Collection<String> c3=new ArrayList<String>();
	    c3.add("Java");
	    
	    c1.retainAll(c3);
	    System.out.println("After retainAll():" +c1);
	    
	    
	    c2.clear();
	    System.out.println("After clear():" +c2);
	    
		
		Object[] arr=c1.toArray();
		System.out.println("Array elements:");
		for(Object obj:arr) {
			System.out.println(obj);
		}
		
		
		Iterator<String> itr=c1.iterator();
		System.out.println("Using iterator");
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
			
		
	}

}



List interface: 
###################
-> It is the child interface of Collection. 

-> If we want to represent a group of individual objects as a single entity where 
duplicates are allow and insertion order is preserved(maintained) . Then we should go for List. 

->We can access the elements using index(like an array)

->Common implementations of List interface is : ArrayList ,LinkedList, Vector(and Stack)


 List-Specific Methods
##########################
List interface defines the following specific methods.  
1. boolean add(int index,Object o); 
2. boolean addAll(int index,Collectio c); 
3. Object get(int index); 
4. Object remove(int index); 
5. Object set(int index,Object new);//to replace 
6. Int indexOf(Object o); 
Returns index of first occurrence of "o". 
7. Int lastIndexOf(Object o); 
8. ListIterator listIterator();

example -
public class ListMethodsExample {

    public static void main(String[] args) {

        // Creating List object
        List<String> list = new ArrayList<>();

        // 1) add(int index, Object o)
        list.add("Java");
        list.add("Spring");
        list.add(1, "Python");

        System.out.println("After add(index, element): " + list);

        // 2) addAll(int index, Collection c)
        List<String> list2 = new ArrayList<>();
        list2.add("Docker");
        list2.add("Kubernetes");

        list.addAll(2, list2);
        System.out.println("After addAll(index, collection): " + list);

        // 3) get(int index)
        System.out.println("Element at index 1: " + list.get(1));

        // 4) remove(int index)
        list.remove(0);
        System.out.println("After remove(index): " + list);

        // 5) set(int index, Object new)
        list.set(1, "Microservices");
        System.out.println("After set(): " + list);

        // 6) indexOf(Object o)
        System.out.println("Index of Docker: " + list.indexOf("Docker"));

        // 7) lastIndexOf(Object o)
        list.add("Docker"); // duplicate
        System.out.println("Last Index of Docker: " + list.lastIndexOf("Docker"));

        // 8) listIterator()
        System.out.println("Using ListIterator:");
        ListIterator<String> itr = list.listIterator();

        while (itr.hasNext()) {
            System.out.println(itr.next());
        }
    }
}
When to use list interface
###########################
Use List when you need :
.To maintain order of elements.
.To access elements by index.
.To allow duplicates.


ArrayList: 
##################
1. The underlying data structure is resizable array (or) growable array. 
2. Duplicate objects are allowed. 
3. Insertion order preserved(maintained). 
4. Heterogeneous objects are allowed.(except TreeSet , TreeMap every where 
heterogenious objects are allowed) .
5. Null insertion is possible. 
6. It is fast for retrieval(read/get) operation because it uses index-based access.
7. It is slower for insertion/deletion in the middle because elements must shift.

Constructors: 
1) ArrayList a=new ArrayList();  
Creates an empty ArrayList object with default initial capacity "10" if ArrayList 
reaches its max capacity then a new ArrayList object will be created with 
             New capacity=(current capacity*3/2)+1  


Difference Between ArrayList and Vector
#######################################
ArrayList and Vector both are classes used to store duplicate elements and maintain insertion order, but the main difference is related to synchronization and performance.

In ArrayList, no method is synchronized. Because of this, at a time multiple threads are allowed to operate on an ArrayList object, so ArrayList is not thread-safe. Since threads are not required to wait, the performance of ArrayList is high.

In Vector, every method is synchronized. Due to this, at a time only one thread is allowed to operate on a Vector object, so Vector is thread-safe. Because threads are required to wait for lock release, the performance of Vector is low compared to ArrayList.

Another difference is that ArrayList is non-legacy and introduced in Java 1.2 version, whereas Vector is a legacy class and introduced in Java 1.0 version.


LinkedList:
#############
1. The underlying data structure is double LinkedList 
2. If our frequent operation is insertion (or) deletion in the middle then LinkedList is 
the best choice. 
3. If our frequent operation is retrieval operation then LinkedList is worst choice. 
4. Duplicate objects are allowed. 
5. Insertion order is preserved. 
6. Heterogeneous objects are allowed. 
7. Null insertion is possible. 
8. Implements Serializable and Cloneable interfaces but not RandomAccess.
9. It's made up of nodes, each storing data and pointers to the next/previous nodes.

Usually we can use LinkedList to implement Stacks and Queues. 
To provide support for this requirement LinkedList class defines the following 6 specific 
methods. 
1. void addFirst(Object o); 
2. void addLast(Object o); 
3. Object getFirst(); 
4. Object getLast(); 
5. Object removeFirst(); 
6. Object removeLast(); 
We can apply these methods only on LinkedList object.

Example:  
import java.util.*; 
class LinkedListDemo  
{ 
 public static void main(String[] args)  
 { 
  LinkedList l=new LinkedList(); 
  l.add("ashok"); 
  l.add(30); 
  l.add(null); 
  l.add("ashok"); 
  System.out.println(l);//[ashok, 30, null, ashok] 
  l.set(0,"software"); 
  System.out.println(l);//[software, 30, null, 
ashok] 
  l.set(0,"venky"); 
  System.out.println(l);//[venky, 30, null, ashok] 
  l.removeLast(); 
  System.out.println(l);//[venky, 30, null] 
  l.addFirst("vvv"); 
  System.out.println(l);//[vvv, venky, 30, null] 
 } 
}   


Vector:
############ 
1. The underlying data structure is resizable array (or) growable array. 
2. Duplicate objects are allowed. 
3. Insertion order is preserved(maintained). 
4. Heterogeneous objects are allowed. 
5. Null insertion is possible(null value allowed). 
6. Implements Serializable, Cloneable and RandomAccess interfaces. 
Every method present in Vector is synchronized and hence Vector is Thread safe.

 Vector v=new Vector();  
o Creates an empty Vector object with default initial capacity 10. 
o Once Vector reaches its maximum capacity then a new Vector object will be 
created with double capacity. That is "newcapacity=currentcapacity*2". 

Example -
class VectorDemo  
{ 
 public static void main(String[] args)  
 { 
  Vector v=new Vector(); 
  System.out.println(v.capacity());//10 
  for(int i=1;i<=10;i++) 
  { 
   v.addElement(i); 
  } 
 System.out.println(v.capacity());//10 
 v.addElement("A"); 
 System.out.println(v.capacity());//20 
 System.out.println(v);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
A] 
 } 


Stack: 
#########
1. It is the child class of Vector. 
2. Whenever last in first out(LIFO) order required then we should go for Stack. 

Constructor: 
It contains only one constructor. 
Stack s= new Stack();  

Methods: 
1. Object push(Object o);   -->To insert an object into the stack. 
2. Object pop();            -->To remove and return top of the stack. 
3. Object peek();           -->To return top of the stack without removal. 
4. boolean empty();         -->Returns true if Stack is empty. 
5. Int search(Object o);    -->Returns offset if the element is available otherwise returns "-1" 

Example:  
import java.util.*; 
class StackDemo  
{ 
 public static void main(String[] args)  
 { 
  Stack s=new Stack(); 
  s.push("A"); 
  s.push("B"); 
  s.push("C"); 
  System.out.println(s);//[A, B, C] 
  System.out.println(s.pop());//C 
  System.out.println(s);//[A, B] 
  System.out.println(s.peek());//B 
  System.out.println(s.search("A"));//2 
  System.out.println(s.search("Z"));//-1 
  System.out.println(s.empty());//false 
 } 
}


The 3 cursors of java: 
#########################
If we want to get objects one by one from the collection then we should go for cursor. 
There are 3 types of cursors available in java. They are:  
1. Enumeration  
2. Iterator  
3. ListIterator  

Enumeration:--->
 
1. We can use Enumeration to get objects one by one from the legacy collection 
objects. 
2. We can create Enumeration object by using elements() method.  
public Enumeration elements();  
Enumeration e=v.elements(); 
using Vector Object  
Enumeration interface defines the following two methods  
1. public boolean hasMoreElements(); 
2. public Object nextElement();

Example:  
import java.util.*; 
class  EnumerationDemo 
{ 
 public static void main(String[] args)  
 { 
  Vector v=new Vector(); 
  for(int i=0;i<=10;i++) 
  { 
   v.addElement(i); 
  } 
  System.out.println(v);//[0, 1, 2, 3, 4, 5, 6, 7, 
8, 9, 10] 
  Enumeration e=v.elements(); 
  while(e.hasMoreElements()) 
  { 
   Integer i=(Integer)e.nextElement(); 
   if(i%2==0) 
    System.out.println(i);//0 2 4 6 8 10 
  } 
  System.out.print(v);//[0, 1, 2, 3, 4, 5, 6, 7, 8, 
9, 10] 
 } 
}

Limitations of Enumeration: 
1. We can apply Enumeration concept only for legacy classes and it is not a universal 
cursor. 
2. By using Enumeration we can get only read access and we can't perform remove 
operations. 
3. To overcome these limitations sun people introduced Iterator concept 
in 1.2v. 


Iterator: 
############
1. We can use Iterator to get objects one by one from any collection object. 

2. We can apply Iterator concept for any collection object and it is a universal cursor. 

3. While iterating the objects by Iterator we can perform both read and remove 
operations. 
We can get Iterator object by using iterator() method of Collection interface.  
public Iterator iterator(); 
Iterator itr=c.iterator();  

Iterator interface defines the following 3 methods.  
1. public boolean hasNext(); 
2. public object next(); 
3. public void remove(); 

Example:  
import java.util.*; 
class IteratorDemo  
{ 
 public static void main(String[] args)  
 { 
  ArrayList a=new ArrayList(); 
  for(int i=0;i<=10;i++) 
  { 
   a.add(i); 
  } 
  System.out.println(a);//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
  Iterator itr=a.iterator(); 
  while(itr.hasNext()) 
  { 
   Integer i=(Integer)itr.next(); 
   if(i%2==0) 
    System.out.println(i);//0, 2, 4, 6, 8, 10 
   else 
    itr.remove(); 
  } 
  System.out.println(a);//[0, 2, 4, 6, 8, 10] 
 } 
} 

Limitations of Iterator: -->
#########################
1. Both enumeration and Iterator are single direction cursors only. That is we can 
always move only forward direction and we can't move to the backward direction. 

2. While iterating by Iterator we can perform only read and remove operations and 
we can't perform replacement and addition of new objects. 

3. To overcome these limitations sun people introduced listIterator concept. 
 
ListIterator: 
#################
1. ListIterator is the child interface of Iterator. 

2. By using listIterator we can move either to the forward direction (or) to the 
backward direction that is it is a bi-directional cursor.
 
3. While iterating by listIterator we can perform replacement and addition of new 
objects in addition to read and remove operations 


ListIterator interface defines the following 9 methods. 
1. public boolean hasNext(); 
2. public Object next(); forward 
3. public int nextIndex(); 
4. public boolean hasPrevious(); 
5. public Object previous(); backward 
6. public int previousIndex(); 
7. public void remove(); 
8. public void set(Object new); 
9. public void add(Object new); 

Example:  
import java.util.*; 
class  ListIteratorDemo 
{ 
 public static void main(String[] args)  
 {  
  LinkedList l=new LinkedList(); 
  l.add("balakrishna"); 
  l.add("venki"); 
  l.add("chiru"); 
  l.add("nag"); 
  System.out.println(l);//[balakrishna, venki, 
chiru, nag] 
  ListIterator itr=l.listIterator(); 
  while(itr.hasNext()) 
  { 
   String s=(String)itr.next(); 
   if(s.equals("venki")) 
   { 
    itr.remove(); 
   } 
  } 
  System.out.println(l);//[balakrishna, chiru, nag] 
 } 
} 

Case 1:  
if(s.equals("chiru")) 
{ 
itr.set("chran"); 
} 
Output: 
[balakrishna, venki, chiru, nag] 
[balakrishna, venki, chran, nag] 

Case 2:  
if(s.equals("nag")) 
{ 
itr.add("chitu"); 
} 
Output: 
[balakrishna, venki, chiru, nag] 
[balakrishna, venki, chiru, nag, chitu] 
The most powerful cursor is listIterator but its limitation is it is applicable only for "List objects".  


Set interface: 
####################
1. It is the child interface of Collection. 
2. If we want to represent a group of individual objects as a single entity where 
duplicates are not allowed and insertion order is not maintained then we should go for Set interface.
3.We can't access the element using index in set interface.

Common Implementations :  HashSet , LinkedHashSet , Treeset 

HashSet: 
##########
1. It internally uses Hashtable. 
2. Insertion order is not maintained and it is based on hash code of the objects. 
3. Duplicate objects are not allowed. 
4. If we are trying to insert duplicate objects we won't get compile time error and 
runtime error add() method simply returns false. 
5. Heterogeneous objects are allowed. 
6. Null value is allowed .(only once) 
7. Implements Serializable and Cloneable interfaces but not RandomAccess. 
8. HashSet is best suitable, if our frequent operation is "Search". 

Constructors: 
1. HashSet h=new HashSet();  
Creates an empty HashSet object with default initial capacity 16 and default fill 
ratio 0.75(fill ratio is also known as load factor). 

Initial capacity means the number of buckets available internally to store elements.
ðŸ‘‰ Default capacity = 16
This means HashSet internally creates a hash table with 16 buckets to store elements.

ðŸ§  What is Fill Ratio (Load Factor)?

Fill ratio (load factor) represents the percentage of capacity after which HashSet increases its size.
ðŸ‘‰ Default fill ratio = 0.75
This means: 16 Ã— 0.75 = 12



LinkedHashSet: 
##################
1. It is the child class of HashSet. 
2. LinkedHashSet is exactly same as HashSet except the following differences. 


Difference Between HashSet and LinkedHashSet
############################################
HashSet and LinkedHashSet both are used to store unique elements, but they differ in internal structure and insertion order behavior.

In HashSet, the underlying data structure is Hashtable. Because of this, insertion order is not preserved. HashSet was introduced in Java 1.2 version.

In LinkedHashSet, the underlying data structure is a combination of LinkedList and Hashtable. Due to this, insertion order is preserved. LinkedHashSet was introduced in Java 1.4 version.

Example:  
import java.util.*; 
class LinkedHashSetDemo  
{ 
 public static void main(String[] args)  
 { 
  LinkedHashSet h=new LinkedHashSet(); 
  h.add("B"); 
  h.add("C"); 
  h.add("D"); 
  h.add("Z"); 
  h.add(null); 
  h.add(10); 
  System.out.println(h.add("Z"));//false 
  System.out.println(h);//[B, C, D, Z, null, 10] 
  } 
}



SortedSet: 
############
1. It is child interface of Set. 

2. If we want to represent a group of "unique objects" where duplicates are not 
allowed and all objects must be inserting according to some sorting order then we should go for SortedSet interface. 

3. That sorting order can be either default natural sorting (or) customized sorting 
order.


TreeSet: 
#########
1. The underlying data structure is balanced tree. 
2. Duplicate objects are not allowed. 
3. Insertion order is not maintained and it stores elements in ascending(natural) order.
4. Heterogeneous objects are not allowed if we are trying to insert heterogeneous objects then we will get ClassCastException. 
5. Null insertion is not allowed.
   Use TreeSet when you want elements in sorted order automatically.

Example 1:  
import java.util.*; 
class TreeSetDemo  
{ 
 public static void main(String[] args)  
 { 
  TreeSet t=new TreeSet(); 
  t.add("A"); 
  t.add("a"); 
  t.add("B"); 
  t.add("Z"); 
  t.add("L"); 
  //t.add(new Integer(10));//ClassCastException 
  //t.add(null);//NullPointerException 
  System.out.println(t);//[A, B, L, Z, a] 
  } 
}

Why Do We Use Comparable Interface?
###################################
The Comparable interface is used to define the natural sorting order of objects.

It is present in the java.lang package and contains only one method:

public int compareTo(Object obj);

The compareTo() method is used to compare the current object with another object and determine the sorting order.

Example:  obj1.compareTo(obj2);
This means:

Returns negative value â†’ obj1 comes before obj2
Returns zero â†’ both objects are equal
Returns positive value â†’ obj1 comes after obj2


Comparator Interface â€“
#####################
The Comparator interface is present in the java.util package. It is used to define custom sorting logic for objects.
Comparator interface defines the following two methods:

1) compare() Method
public int compare(Object obj1, Object obj2);

This method is used to compare two different objects.

2) equals() Method
public boolean equals(Object obj);

This method is used to check whether two Comparator objects are equal or not.


Difference Between Comparable and Comparator 
###############################################
Comparable is meant for default natural sorting order, whereas Comparator is meant for customized sorting order.

Comparable interface is present in the java.lang package, while Comparator interface is present in the java.util package.

Comparable contains only one method, that is compareTo() method, whereas Comparator contains two methods, that is compare() method and equals() method.

String class and all wrapper classes implement Comparable interface, but the only implemented classes of Comparator are Collator and RuleBasedCollator, which are mainly used in GUI-based applications.



Map: 
#########################################################################################################

1. If we want to represent a group of objects as "key-value" pair then we should go for Map interface. 
2. Both key and value are objects only. 
3. Duplicate keys are not allowed but values can be duplicated 
4. Each key-value pair is called "one entry". 


ï‚· Map interface is not child interface of Collection and hence we can't apply 
Collection interface methods here. 

ï‚· Map interface defines the following specific methods. 
1. Object put(Object key,Object value);  
To add an entry to the Map, if key is already available then the old value replaced with new value and old value will be returned. 

2. import java.util.*; 
3. class Map  
4. { 
5.  public static void main(String[] args)  
6.  { 
7.   HashMap m=new HashMap(); 
8.   m.put("100","vijay"); 
9.   System.out.println(m);//{100=vijay} 
10.   m.put("100","ashok"); 
11.   System.out.println(m);//{100=ashok} 
12.  } 
13. } 


HashMap: 
##############
1. The underlying data structure is Hashtable. 
2. Duplicate keys are not allowed but values can be duplicated. 
3. Insertion order is not maintained and it is based on hash code of the keys. 
4. Heterogeneous objects are allowed for both key and value. 
5. Null is allowed for keys(only once) and for values(any number of times). 
6. It is best suitable for Search operations.
7.It implements Map interface.  
8. It uses an array of buckets and linked lists to store key-value pairs.

Constructors: 
1. HashMap m=new HashMap();  
Creates an empty HashMap object with default initial capacity 16 and default fill 
ratio "0.75".

Difference Between HashSet and HashMap (Interview Explanation)
###############################################################
HashSet and HashMap both use hashing technique internally, but they are used for different purposes.

HashSet is used to store only values, whereas HashMap is used to store key-value pairs.

In HashSet, we can add elements directly as objects. But in HashMap, we must provide both key and value while storing data.

HashSet does not allow duplicate elements, because it stores unique values. Similarly, HashMap does not allow duplicate keys, but it allows duplicate values.

In HashSet, there is no concept of key, whereas in HashMap, every value is stored using a unique key.

Internally, HashSet is implemented using HashMap. HashSet stores elements as keys and uses a dummy object as value.



Difference Between HashMap and Hashtable 
##########################################
HashMap and Hashtable both are used to store data in key-value pairs, but they differ in synchronization, performance, and null handling.

In HashMap, no method is synchronized. Because of this, multiple threads can operate simultaneously on a HashMap object, so HashMap is not thread-safe. Since threads are not required to wait, the performance of HashMap is high.

In Hashtable, every method is synchronized. Due to this, multiple threads cannot operate simultaneously on a Hashtable object, so Hashtable is thread-safe. Because threads are required to wait, the performance of Hashtable is low compared to HashMap.

Another difference is that HashMap allows null values for both key and value, whereas Hashtable does not allow null for both key and value, otherwise it will throw NullPointerException.

Finally, HashMap is non-legacy and introduced in Java 1.2 version, while Hashtable is a legacy class and introduced in Java 1.0 version.



How to get synchronized version of HashMap: 
###############################################
By default HashMap object is not synchronized. But we can get synchronized version by using the following method of Collections class. 
public static Map synchronizedMap(Map m1)  .


How HashMap Works Internally
###############################################
HashMap works based on hashing technique to store data in key-value pairs.

When we insert an element using put(key, value), first the hashCode() method of the key is called to generate a hash value. Using this hash value, HashMap calculates the bucket index where the entry should be stored.

If the calculated bucket is empty, the key-value pair is stored directly.

If the bucket is not empty, it means a collision occurred. In this case, HashMap uses a LinkedList (before Java 8) or LinkedList and Red-Black Tree (from Java 8 onwards) to store multiple entries in the same bucket. Then it compares keys using the equals() method. If the key already exists, the value is updated; otherwise, a new entry is added.

When the number of entries crosses 75% of the capacity (load factor 0.75), HashMap performs rehashing, where the internal array size is increased and all entries are redistributed.


LinkedHashMap vs HashMap (Interview Explanation)
#################################################

LinkedHashMap is exactly same as HashMap except the following differences:

In HashMap, the underlying data structure is Hashtable, and insertion order is not maintaINED. HashMap was introduced in Java 1.2 version.

In LinkedHashMap, the underlying data structure is a combination of Hashtable and LinkedList, and insertion order is preserved. LinkedHashMap was introduced in Java 1.4 version.



What is Collision and How to Overcome It?
########################################
Collision occurs in HashMap when two different keys generate the same hash index and try to store their values in the same bucket.
HashMap overcomes collision by using LinkedList and Red-Black Tree data structures to store multiple entries in the same bucket.

IdentityHashMap: 
##################### 

It is exactly same as HashMap except the following differences:  
1. In the case of HashMap JVM will always use ".equals()"method to identify 
duplicate keys, which is meant for content comparision. 
2. But in the case of IdentityHashMap JVM will use== (double equal operator) to 
identify duplicate keys, which is meant for reference comparision.


WeakHashMap: 
###############
It is exactly same as HashMap except the following differences:  
ï‚· In the case of normal HashMap, an object is not eligible for GC even though it 
doesn't have any references if it is associated with HashMap. That is HashMap  dominates garbage collector. 

ï‚· But in the case of WeakHashMap if an object does not have any references then 
it's always eligible for GC even though it is associated with WeakHashMap that is 
garbage collector dominates WeakHashMap. 

SortedMap:
############## 
ï‚· It is the child interface of Map. 
ï‚· If we want to represent a group of key-value pairs according to some sorting order 
of keys then we should go for SortedMap. 
ï‚· Sorting is possible only based on the keys but not based on values. 
ï‚· SortedMap interface defines the following 6 specific methods.  
1. Object firsyKey(); 
2. Object lastKey(); 
3. SortedMap headMap(Object key); 
4. SortedMap tailMap(Object key); 
5. SortedMap subMap(Object key1,Object key2); 
6. Comparator comparator(); 
 
TreeMap: 
############
1. The underlying data structure is RED-BLACK Tree. 
2. Duplicate keys are not allowed but values can be duplicated. 
3. Insertion order is not preserved and all entries will be inserted according to some 
sorting order of keys. 
4. If we are depending on default natural sorting order keys should be homogeneous 
and Comparable otherwise we will get ClassCastException. 
5. If we are defining our own sorting order by Comparator then keys can be 
heterogeneous and non Comparable. 
6. There are no restrictions on values they can be heterogeneous and non 
Comparable. 
7. For the empty TreeMap as first entry null key is allowed but after inserting that 
entry if we are trying to insert any other entry we will get NullPointerException. 
8. For the non empty TreeMap if we are trying to insert an entry with null key we will 
get NullPointerException. 
9. There are no restrictions for null values. 


Hashtable: 
#############
1. The underlying data structure is Hashtable. 
2. Insertion order is not preserved and it is based on hash code of the keys. 
3. Heterogeneous objects are allowed for both keys and values. 
4. Null key (or) null value is not allowed otherwise we will get NullPointerException. 
5. Duplicate keys are allowed but values can be duplicated. 
6. Every method present inside Hashtable is syncronized and hence Hashtable objet is 
Thread-safe. 



Queue interface 
##################

1. Queue is child interface of Collections. 
2. If we want to represent a group of individual objects prior (happening before 
something else) to processing then we should go for Queue interface.
 
3. Usually Queue follows first in first out(FIFO) order but based on our requirement 
we can implement our own order also. 

4. From 1.5v onwards LinkedList also implements Queue interface. 

5. LinkedList based implementation of Queue always follows first in first out order. 
Assume we have to send sms for one lakh mobile numbers , before sending messages we 
have to store all mobile numbers into Queue so that for the first inserted number first 
message will be triggered(FIFO). 

PriorityQueue: 
##################
1. PriorityQueue is a data structure to represent a group of individual objects prior to 
processing according to some priority. 

2. The priority order can be either default natural sorting order (or) customized 
sorting order specified by Comparator object. 

3. If we are depending on default natural sorting order then the objects must be 
homogeneous and Comparable otherwise we will get ClassCastException. 

4. If we are defining our own customized sorting order by Comparator then the 
objects need not be homogeneous and Comparable. 

5. Duplicate objects are not allowed. 
6. Insertion order is not preserved but all objects will be inserted according to some 
priority. 
7. Null is not allowed even as the 1st element for empty PriorityQueue.Otherwise we 
will get the "NullPointerException". 
